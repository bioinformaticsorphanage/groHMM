
herve <hpages@fhcrc.org> added the comment:

Hi Minho,

Thanks for submitting the groHMM package and sorry for the delay in getting back to you. I had a 1st look at the package and found a significant amount of issues that I'm listing below. The package requires a good amount of work to meet our standards. Once your done, please upload a new tarball in this issue again (Issue690) and I'll have a 2nd look.

Please let me know or ask on the Bioc-devel mailing list if you need help or have any question about this. Thanks!

H.

============================================================================

General:

1.a - Packages used in the vignette (GenomicFeatures, edgeR, org.Hs.eg.db) need
  to be listed in the Suggests field.
=> Done!

1.b - Please remove inst.tgz from the groHMM/inst/ folder, and groHMM.R from
  the groHMM/inst/doc/ folder.
=> Done!

1.c - Description field in DESCRIPTION file:

    This package is an analysis pipeline for the analysis of GRO-seq data.

  Using a less verbose style is preferred:

    A pipeline for the analysis of GRO-seq data.
=> Done!

1.d - Why implement your own writeWiggle() function when exporting a GRanges
  object to a wig file is already supported by the export() function in
  the rtracklayer package:

       library(rtracklayer)
       test_path <- system.file("tests", package="rtracklayer")
       test_wig <- file.path(test_path, "step.wig")
       test <- import(test_wig)
       export(test, "test.wig", format="wig")

  Doing writeWiggle(test, "test2.wig", size=300) takes longer,
  only supports fixed-step wiggle, takes more time, and generates a much
  bigger file (1800x bigger).

1.e - Your countReadsInInterval() function is basically a re-implementation
  of countOverlaps(). Like with writeWiggle()/export() above, it is of course
  preferable to re-use a well tested function like countOverlaps() that is
  already used by many Bioconductor packages and subject to ongoing
  improvements and optimizations.

Man pages:

2.a - The package entry-point man page (accessible with ?`groHMM-package`) is
  missing.

2.b - You have no \examples section in none of your man page! Every function
  defined in your package needs to have working examples in the man pages.

2.c - The \value section needs to tell exactly what the returned object is.
  For example, the detectTranscripts() function seems to return a list
  with 4 components. Only 1 of the 4 components is a GRanges object and
  the man page only describes this component:

     Returns a GRanges object representing the predicted genomic
     coordinates of transcripts on both the + and - strand.

  Strictly speaking, this description is not only incomplete, it's incorrect
  because it suggests that the top-level object is a GRanges object which is
  not the case.
  Please visit all the man pages in the package and make sure the \value
  section is complete and accurate.

2.d - The description of what a function does is generally too vague or
  minimalist to be really useful. For example, the description of what
  makeConsensusAnnotations() does is:

     Makes a consensus annotation which is a non overlapping annotation
     where multiply covered isoforms are used to represent a genomic
     ranges for the gene.  This also reduces annotations in a way to
     save starting site of a gene for overlapping gene annotations.

  This is too vague. Please provide a \details section where you explain
  exactly what "multiply covered isoforms" are and how they are used to
  "represent a genomic range for the gene". Also what do you mean by
  "to save starting site of a gene for overlapping gene annotations"?

Vignette:

3.a - The hah.chr7.RData dataset needs to be documented in a much more precise
  way. There needs to be a man page for it explaining how the serialized GRanges
  objects were obtained. Also note that it's usually better to provide the
  BAM files used to create those GRanges objects (possibly subsetted to include
  data from a particular chromosome only) and to load them in GRanges objects
  with something like 'as(readGAlignments(..), "GRanges")' when needed.

  Otherwise, if you decide you want to keep the reads in serialized GRanges
  objects (which I don't recommend) the normal place for such dataset
  (which contains serialized objects) is to put it under the data/ folder.
  The extdata/ folder is for data files that do not contain serialized objects
  (e.g. GTF, BAM, FASTA, etc...), or for data files that contain serialized
  objects that are not accessed directly by the user.

3.b - Please use consistent case for GRO-seq (sometimes you use GRO-Seq,
  sometimes GRO-seq).

3.c - The vignette contains many typos:
  plolymerases (instead of polymerases), becuase (instead of because),
  advantageous (instead of advantages), death (instead of depth), etc...

3.d - Any reason to use the refGene track instead of the knownGene track
  for hg19? The reason I ask is that Bioconductor provides a few pre-made
  TranscriptDb objects wrapped into what we called "TxDb packages" and
  TxDb.Hsapiens.UCSC.hg19.knownGene is one of them (unfortunately there is
  no TxDb.Hsapiens.UCSC.hg19.refGene package but it could be added if enough
  people were requesting this on the mailing list). Using the TranscriptDb
  object that is in TxDb.Hsapiens.UCSC.hg19.knownGene is very simple:

    library(TxDb.Hsapiens.UCSC.hg19.knownGene)
    txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene

  and it takes less than 1 or 2 seconds.
  OTOH, making your own TranscriptDb object with makeTranscriptDbFromUCSC()
  (like you do in the vignette) takes several minutes.
  I can see that may be you didn't want to use the knownGene track because
  not all transcripts are linked to a gene in that track:

    tx <- transcripts(txdb, vals=list(tx_chrom="chr7"),
                      columns=c("gene_id", "tx_id", "tx_name"))

  Then:

    > table(elementLengths(mcols(tx)$gene_id))
       0    1 
     564 3281 

  And that seems to cause problems in your makeConsensusAnnotations(). But
  that means that this function needs to be fixed, not that the knownGene
  track is not a good track. More on this below.

R code:

4.a - Don't use the assignment operator (<-) for passing named arguments:

    rgChr7 <- transcripts(rgdb, vals <- list(tx_chrom="chr7"),
                          columns=c("gene_id", "tx_id", "tx_name"))

  This is a very bad idea and it will bite you one day. Please use = instead.

4.b - Don't use print(paste()) to print informative messages in your functions.
  This generates ugly output. Please use message() or cat() instead (no need
  to paste() the strings before you pass them to message() or cat()). The
  advantage of message() over cat() is that the user can wrap the call to
  your function inside suppressMessages() to get rid of all the messages.

4.c - In addition to be poorly documented, the makeConsensusAnnotations()
  function has many problems.
  One is this line of code (in makeConsensusAnnotations.R):

    annoList <- GenomicRanges::split(anno, GenomicRanges::unlist(mcols(anno)
[,keytype]))

  First note that prefixing the calls to split of unlist with GenomicRanges::
  is not needed.

  But more importanly, it seems that you are assuming that unlisting
  'mcols(anno)[,keytype]' will always give you an atomic vector of the
  same length as 'anno'. In other words, it seems that you are assuming
  that all the list elements in 'mcols(anno)[,keytype]' have length 1.
  This assumption is dangerous. For example, the following result (using the
  'tx' object obtained in 3.d) is wrong;

    > txConsensus <- makeConsensusAnnotations(tx[1:5], keytype="gene_id")
    > txConsensus
    GRanges with 2 ranges and 3 metadata columns:
                seqnames           ranges strand |         gene_id     tx_id
                   <Rle>        <IRanges>  <Rle> | <CharacterList> <integer>
          56975     chr7 [149744, 154868]      + |                     27176
      100288524     chr7 [192969, 300740]      + |           56975     27178
                    tx_name
                <character>
          56975  uc003sio.1
      100288524  uc003sip.3
      ---
      seqlengths:
                        chr1                  chr2 ...        chrUn_gl000249
                   249250621             243199373 ...                 38502

  And the reason it's wrong is because of this:

    > mcols(tx[1:5])$gene_id
    CharacterList of length 5
    [[1]] character(0)
    [[2]] character(0)
    [[3]] 56975
    [[4]] 56975
    [[5]] 100288524
    > unlist(mcols(tx[1:5])$gene_id)
    [1] "56975"     "56975"     "100288524"

  so 'split(tx, unlist(mcols(tx[1:5])$gene_id))' is not doing what you have
  in mind.

  Note that the "gene_id" metadata column is a CharacterList so you cannot
  exclude the possibility to have list elements of length 2. That doesn't
  mean that you need to be able to reduce the annotation if this happens.
  Raising an error is perfectly fine, but your code needs to check for this
  situation and fail gracefully if it happens.

4.d - makeConsensusAnnotations() has many other problems. For example, it
  breaks in an obscure way if all the genes only have 1 transcript:

    > makeConsensusAnnotations(rgChr7[1:3])[1] "Genes with no isoforms: 3"
    Error in GenomicRanges::unlist(endoapply(isoList, function(x) x[1, ])) : 
      error in evaluating the argument 'x' in selecting a method for function
'unlist': Error in sapply(listData, function(Xi) extends(class(Xi),
elementTypeX)) : 
      error in evaluating the argument 'X' in selecting a method for function
'sapply': Error in IRanges:::normalizeSingleBracketSubscript(i, x) : 
      subscript contains NAs or out of bounds indices

  It's also very slow and its implementation seems unnecessary complicated,
  buggy, and lacks robustness.

  Please revisit the implementation of the function and make sure your
  code is clean, robust, efficient, and that the function is well tested
  and well documented.

4.e - Use the standard idioms whereever you can. For example, in the
  countReadsInInterval() function, use 'seq_along(C)' instead of
  'c(1:NROW(C))'. 3 problems with 'c(1:NROW(C))': (1) c(...) is unneeded,
  (2) it will break if C has length 0, (3) the use of NROW() on a character
  vector is confusing. Using 'seq_along(C)' or 'seq_len(length(C))' is the
  idiom any serious R programmer will use in this case.

C++ code:

5.a - Are you sure you need the Makevars and Makevars.win files? Your package
  will compile out-of-the-box without them. Those files define some symbol
  (_USE_MEM_MAPPING_ and _MSC_VER) and change the optimization level to 0
  (default is 2 on Linux) which is generally not a good idea (unless you have
  a really good reason for doing this).

5.b - Your R_init_* function is not named correctly: R_init_GROseq.
  Needs to be R_init_groHMM otherwise it's not being called at load time.

5.c - I suggest you use PROTECT/UNPOTECT consistently thru all your code,
  and not sometimes PROTECT, sometimes protect, sometimes UNPROTECT, and
  sometimes unprotect. This will make your code easier to read and understand.

5.d - You don't need to PROTECT() objects returned by getAttrib() or, more
  generally, objects that you get by extracting parts of a bigger object.
  For example, you are not protecting objects returned by VECTOR_ELT() or
  STRING_ELT(), which is good.

5.e - Writing code in a simple, clear and consise way is a great vertue as
  it tends to produce software that has less bug and is easier to maintain.
  For example it's very hard for me to understand the reason for the
  following repetitions in the RBaumWelchEM function (in the hmmEM.cpp file,
  lines 154 to 165):

    if(strcmp(CHAR(STRING_ELT(emiprobDist, i)), "norm") == 0){
            sstats_alloc[i] = SSallocNormal;
            sstats_emis[i]  = SStatsNormal;
            update_emis[i]  = UpdateNormal;
            free_emis_s[i]  = SSfreeNormal;
    }
    else if(strcmp(CHAR(STRING_ELT(emiprobDist, i)), "dnorm") == 0){
            sstats_alloc[i] = SSallocNormal;
            sstats_emis[i]  = SStatsNormal;
            update_emis[i]  = UpdateNormal;
            free_emis_s[i]  = SSfreeNormal;
    }

  when this could simply be implemented with:

    if(strcmp(CHAR(STRING_ELT(emiprobDist, i)), "norm") == 0
    || strcmp(CHAR(STRING_ELT(emiprobDist, i)), "dnorm") == 0){
            sstats_alloc[i] = SSallocNormal;
            sstats_emis[i]  = SStatsNormal;
            update_emis[i]  = UpdateNormal;
            free_emis_s[i]  = SSfreeNormal;
    }

I can't detail all the issues that I see in the package but the above list gives you an idea of the kind of issues that need to be addressed, and hopefully also provides some directions and useful hints. To summarize, my general impression about the current state of the package is that:
  1. Functionalities already available in Bioconductor should not be
     re-implemented, especially functionalities provided by low-level
     infrastructure packages like IRanges, GenomicRanges, and rtracklayer.
  2. The code (R and C++) lacks clarity and simplicity. As a result
     it's very hard to read, to understand, and to assess its correctness.
  3. The documentation of the individual functions is too incomplete or
     inaccurate to get a good understanding of their intended semantic.
Therefore a significant effort towards better implementation and better documentation is needed.

----------
status: preview-in-progress -> sent-back

__________________________________________________________
Bioconductor file submit tracker <submit@bioconductor.org> <http://tracker.fhcrc.org/roundup/bioc_submit/issue690>
__________________________________________________________

